<!DOCTYPE html>
<html>
<head>
	<title>openModal Demo</title>
	<script defer src="openModal.js"></script>
	<link rel="stylesheet" href="./style.css">
</head>
<body>
	<strong>UNDER CONSTRUCTION</strong>
	<h1>openModal - A New Concept For Modal Dialogs/Windows</h1>
	<p><a href="openModal.js">openModal.js</a> allows you to easily create accessible, nestable, modal dialogs/windows.</p>
	<p>Think of <code>openModal(url)</code> as an alternative to <code>window.open(url)</code>. Instead of opening a new tab or pop-up window, it opens a "modal window" over top of your existing page.</p>
	<p>The modal window has a transparent background, so the document loaded in that window is free to let the parent window show through. All user interaction in the parent window is blocked until the modal window is closed.</p>
	<p>
		<button onclick="openModal('basic_features.html')">Try it out</button>
		<button 
			id="alert_something" 
			onclick="alert('This button is a dummy element, which we try to click with javascript from the demo modal. This alert message should NOT appear when you click the test button in the modal window');"
			style="opacity: 0.5;"
		>
			Test Button
		</button>
		<br>

		<button onclick="openModal('no_autofocus.html');">
			Try it out (no <code>autofocus</code> element)
		</button>
	</p>

	<p>Our implementation loads the the document in an iframe, but this detail is not exposed in the API. We've designed the API to be as simple as possible, serving one well-defined role. Our hope is that this API may be considered for native implementation on the web.</p>

	<h2>API</h2>
	<h3><code>openModal(url, [options]) -> undefined</code></h3>
	<p>Opens a "modal window" over top of the current window, containing the document at the specified url.</p>

	<p>The <code>options</code> argument, if given, must be an object specifying any of these properties:</p>
	<dl>
		<dt><code>background: string</code></dt>
		<dd>A style to use as the modal's background. Generally, you can just set the background style on the <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code> element within your modal. However, if the modal window performs any navigation within itself, you may want to set this value, so that the background persists during navigations. <br>

		<button type="button" onclick="openModal('full_page.html');">Without background</button>
		<button type="button" onclick="
			openModal('full_page.html', {background: 'white'});
		">With iframe background</button>
		</dd>

		<dt><code>onload: function(window) -> undefined</code></dt>
		<dd>
			This callback will be invoked every time the modal window loads. <br>
			<button onclick="
				openModal('onload_test.html', {onload: function(w) {
					w.initialize('foobar');
				}});
			">Try it out</button>
		</dd>

		<dt><code>onclose: function(any) -> undefined</code></dt>
		<dd>This callback will be invoked when the modal is closed. The argument will the value that was passed to <code>closeModal()</code>. <br>
		<button onclick="
			openModal('onclose_test.html', {
				onclose: function(value) {
					alert('The modal window closed with value '+value);
				},
			});">Try it out</button>
		</dd>
	</dl>

	<p>Inside the modal window, the following will be available:</p>
	<dl>
		<dt><code>parent</code></dt>
		<dd>The parent window (which called <code>openModal()</code>). The modal window can also navigate the parent using links with <code>target="_parent"</code>.<br> <small>These are standard features available in any iframe, but we explicitly endorse their use. We suggest that any native implementation of <code>openModal()</code> should also make these features available, even if that implementation does not use iframes.</small></dd>
		<dt><code>closeModal([value]) -> undefined</code></dt>
		<dd>Closes the modal window. If given, <code>value</code> will be passed to the <code>onclose</code> callback</dd>
	</dl>

	<h2>Nesting</h2>
	<p>Nesting is straightforward, with one caveat. To prevent infinite recursion, browsers block iframes from loading if their src matches the src of any parent iframe. See the "Infinite Recursion" section of the <a href="https://www.w3.org/TR/WD-frames-970331">relevant W3C document</a>.</p>
	<p>Generally, you won't have a need to open iframes in a cycle like this. If you do, just append a unique querystring to each src, like we do in this demo:<br>
	<button type="button" onclick="openModal('nestable_alert.html');">Nesting Demo</button>
	</p>

	<h2>Going Native</h2>
	If a native implementation of <code>openModal()</code> was implemented, some additional features could be added (<small>some or all of these features <em>may</em> be possible with a pure javascript solution, but the implementations would likely be hacks that fail in various edge cases)</small>).

	<h3><code>target="_modal"</code></h3>
	<p>Any link with this target will open the linked document in a modal window.</p>

	<h3>Top Reload</h3>
	<p>Any user-initiated reload would only reload the top-most window.</p>

	<h3>"Independent" Windows</h3>
	<p>If window A opens ModalWindow B, then A and B are said to be <dfn>independent</dfn> until A adds any event listeners to B.</p>
	<p>Some additional features could be added which are only supported for independent windows.</p>
	<h4>Bottom Reload</h4>
	<p>If window A is covered by (independent) window B, and window A executes <code>location.reload()</code>, then A will reload and B will remain open.</p>
	<p>This is useful, for example, if A is a "detail" view and B is a form to edit the object shown in A. B can communicate with A (ie. via <code>window.parent.someGlobalCallback()</code>) whenever the user commits a change, and A can then reload so that it reflects those changes. Or, in a situation this simple, B could directly call <code>window.parent.location.reload()</code> to reload A every time the user commits a change.</p>

	<h4>History Navigation</h4>
	<p>Opening an independent modal should create a new history state. If the user goes "back", the modal should be closed (assuming it cannot go back any further in its own history). The user should then be able to go "forward" to reopen the modal.</p>

	<h2>Tips &amp; Design Patterns</h2>

	<p>You already know everything there is to know about <code>openModal()</code>. What follows is a set of tips/techniques for implementing common design patterns.</p>


	<h3>Easy Exit</h3>
	<p>Close the modal when clicking outside the main "visible element" or by hitting the escape key:<br>
	<button onclick="openModal('easy_exit.html');">Easy Exit Demo</button>

	<h3>Alert Modal</h3>
	<p>The alert modal we've been using thus far is very flexible. It requires two wrapper elements inside the body, and you must include <a href="alertModal.css">alertModal.css</a>. Feel free to copy alertModal.css to your own project, and edit to your liking. We've included comments indicating which styles you may want to override.</p>
	<p>Note that in each of the following demos we actually load the same document, but we mutate the styles within the modal via <code>load</code> listeners. This is for demonstration purposes only. In general, you should leave such styling up to the document you are opening.</p>
	
	<button type="button" onclick="openModal('alert.html');">
		Open Alert Modal</button>
	<button type="button" onclick="
		var mw = openModal('alert.html');
		mw.addEventListener('load', function() {
			mw.contentWindow.document.documentElement.classList.add('alertModalTopBiased');
		});
	">
		"Top Biased" variant</button>
	<button type="button" onclick="
		var mw = openModal('alert.html');
		mw.addEventListener('load', function() {
			mw.contentWindow.document.documentElement.style.alignItems = 'center';
		});
	">
		Vertically Centered</button>
	<button type="button" onclick="
		var mw = openModal('alert.html');
		mw.addEventListener('load', function() {
			var div = mw.contentWindow.document.body.firstElementChild;
			div.style.width = '800px';
			div.style.height = '500px';
		});
	">
		Initial Dimensions</button>

	<h2>TODO</h2>
	<h3>More design patterns</h3>
	<p>Draggable windows, edge snapping, etc.</p>
	
	<h3>Cross Origin Iframes</h3>
	<p>We plan to support cross origin iframes. The following limitations will apply:</p>
	<ul>
		<li>the iframe's document must also include openModal.js</li>
		<li>any inter-window communication you perform in <code>onload</code> must be limited to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage API</a></li>
		<li>any value passed to <code>closeModal()</code> must serializable by the postMessage API</li>
	</ul>

	<h3>Cross Browser Testing</h3>
	<p>'nough said.</p>

	<h3>Opera Mini Support</h3>
	<p>We rely on <code>position: fixed;</code>. Opera Mini appears to be the only current browser not supporting this (<a href="https://caniuse.com/#feat=css-fixed">https://caniuse.com/#feat=css-fixed</a>).</p>
	<p>We may be able to implement a fallback using <code>position: absolute;</code> and calculating the required top/left values using <code>iframe.getBoundingClientRect()</code> after initially placing it in the DOM.</p>

	<h3>Smarter Scroll Locking</h3>
	<p>We use a scoll event listener to lock the document scroll position, rather than setting <code>overflow: hidden;</code> while a modal is open.</p>
	<p>The latter technique is more efficient, and would prevent any "jitter" while the user scrolls. However, it should not be used if the browser renders scroll bars that take up space in the viewport (showing/hiding scrollbars when opening a modal can be distracting, or even break layouts entirely).</p>
	<p>We can probably detect, at the time <code>openModal()</code> is called, whether there are currently any "space taking" scrollbars, and use the most appropriate technique.</p>
</body>
</html>