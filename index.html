<!DOCTYPE html>
<html>
<head>
	<title>openModal Demo</title>
	<script defer src="openModal.js"></script>
	<link rel="stylesheet" href="./style.css">
</head>
<body>
	<strong>UNDER CONSTRUCTION</strong>
	<h1>openModal - A New Concept For Modal Dialogs/Windows</h1>
	<p><a href="openModal.js">openModal.js</a> allows you to easily create accessible, nestable, modal dialogs/windows.</p>
	<p>Think of <code>openModal(url)</code> as an alternative to <code>window.open(url)</code>. Instead of opening a new tab or pop-up window, it opens a "ModalWindow" over top of your existing page.</p>
	<p>Our implementation loads the the document in an iframe, but this detail is not exposed in the API. We've designed the API to be as simple as possible, and to mimic existing browser APIs, in the hopes that this function might one day be considered for native browser implementation.</p>

	<h2>API</h2>
	<p><code>openModal(url, [options])</code> creates a "ModalWindow" object, from the document at the specified url.</p>

	<p>The ModalWindow:</p>
	<ul>
		<li>blocks all user interaction in the parent window until closed</li>
		<li>covers the entire viewport</li>
		<li>has a transparent background, so need not <em>visually</em> block the entire parent window</li>
	</ul>

	<p>The ModalWindow implements:</p>
	<dl>
		<dt><code>contentWindow</code></dt>
		<dd>A Window object. This allows you to communicate with the modal.</dd>

		<dt><code>addEventListener/removeEventListener</code></dt>
		<dd>You can listen to "load" and "close" events. The load event is fired on every page load within the modal. The close event is fired when the ModalWindow is closed.</dd>

		<dt><code>close([value]) -> undefined</code></dt>
		<dd>Closes the ModalWindow. If given, <code>value</code> will be available on the close event as <code>event.detail</code></dd>
	</dl>

	<p>Inside the modal (inside it's <code>contentWindow</code>), the following will be available:</p>
	<dl>
		<dt><code>parent</code></dt>
		<dd>The opening/parent Window.</dd>
		<dt><code>closeModal([value]) -> undefined</code></dt>
		<dd>Allows the modal to close itself. If given, <code>value</code> will be available on the close event as <code>event.detail</code></dd>
	</dl>
	
	<p>The <code>options</code> argument, if given, must be an object specifying any of these properties:</p>
	<dl>
		<dt><code>background</code></dt>
		<dd>A string declaring the style of the modal's background. Generally, you can just set the background style on the <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code> element within your modal. However, if the modal performs any navigation within its own <code>contentWindow</code>, you may want to set this value, so that the background persists during navigations. <br>

		<button type="button" onclick="openModal('full_page.html');">Without background</button>
		<button type="button" onclick="
			openModal('full_page.html', {background: 'white'});
		">With iframe background</button>
		</dd>
	</dl>

	<h2 id="demos" style="position: relative; z-index: 9007199254740991;">Demos</h2>
	<p>
		<button type="button" onclick="openModal('basic_features.html');">
			Accessibility / Usability Features</button>
		<button onclick="
			openModal('communication_demo.html', {
				onload: function(w) {
					w.initialize(5);
				},
				onclose: function(value) {
					alert('The modal window closed with value '+value);
				},
			});
		">Inter-window Communication</button>

		<button type="button" onclick="openModal('nestable_alert.html');">Nesting</button>

		<!-- 
			This button is here so that so that the 'basic_features.html' demo
			has something to try and click (programmatically)
		-->
		<br>

	</p>
	<p>
		Test button for the accessibility demo (it tries to click this): <br>
		<button id="alert_something" onclick="alert('You clicked the test button');">
			Test Button</button>
	</p>

	<h2>Going Native</h2>
	If a native implementation of <code>openModal()</code> was implemented, some additional features could be added (<small>some or all of these features <em>may</em> be possible with a pure javascript solution, but the implementations would likely be hacks that fail in various edge cases)</small>).

	<h3><code>target="_modal"</code></h3>
	<p>Any link with this target will open the linked document in a modal window.</p>

	<h3>Top Reload</h3>
	<p>Any user-initiated reload would only reload the top-most window.</p>

	<h3>"Independent" Windows</h3>
	<p>If window A opens ModalWindow B, then A and B are said to be <dfn>independent</dfn> until A adds any event listeners to B.</p>
	<p>Some additional features could be added which are only supported for independent windows.</p>
	<h4>Bottom Reload</h4>
	<p>If window A is covered by (independent) window B, and window A executes <code>location.reload()</code>, then A will reload and B will remain open.</p>
	<p>This is useful, for example, if A is a "detail" view and B is a form to edit the object shown in A. B can communicate with A (ie. via <code>window.parent.someGlobalCallback()</code>) whenever the user commits a change, and A can then reload so that it reflects those changes. Or, in a situation this simple, B could directly call <code>window.parent.location.reload()</code> to reload A every time the user commits a change.</p>

	<h4>History Navigation</h4>
	<p>Opening an independent modal should create a new history state. If the user goes "back", the modal should be closed (assuming it cannot go back any further in its own history). The user should then be able to go "forward" to reopen the modal.</p>

	<h2>Tips &amp; Design Patterns</h2>

	<p>You already know everything there is to know about <code>openModal()</code>. What follows is a set of tips/techniques for implementing common design patterns.</p>

	<h3>Nesting</h3>
	<p>Nesting is straightforward, with one caveat. To prevent infinite recursion, browsers block iframes from loading if their src matches the src of any parent iframe. See the "Infinite Recursion" section of the <a href="https://www.w3.org/TR/WD-frames-970331">relevant W3C document</a>.</p>
	<p>Generally, you won't have a need to open iframes in a cycle like this. If you do, just append a unique querystring to each src, like we do in this demo:<br>
	<button type="button" onclick="openModal('nestable_alert.html');">Nesting Demo</button>
	</p>

	<h3>Easy Exit</h3>
	<p>Close the modal when clicking outside the main "visible element" or by hitting the escape key:<br>
	<button onclick="openModal('easy_exit.html');">Easy Exit Demo</button>

	<h3>Alert Modal</h3>
	<p>The alert modal we've been using thus far is very flexible. It requires two wrapper elements inside the body, and you must include <a href="alertModal.css">alertModal.css</a>. Feel free to copy alertModal.css to your own project, and edit to your liking. We've included comments indicating which styles you may want to override.</p>
	<p>Note that in each of the following demos we actually load the same document, but we mutate the styles within the modal via <code>load</code> listeners. This is for demonstration purposes only. In general, you should leave such styling up to the document you are opening.</p>
	
	<button type="button" onclick="openModal('alert.html');">
		Open Alert Modal</button>
	<button type="button" onclick="
		var mw = openModal('alert.html');
		mw.addEventListener('load', function() {
			mw.contentWindow.document.documentElement.classList.add('alertModalTopBiased');
		});
	">
		"Top Biased" variant</button>
	<button type="button" onclick="
		var mw = openModal('alert.html');
		mw.addEventListener('load', function() {
			mw.contentWindow.document.documentElement.style.alignItems = 'center';
		});
	">
		Vertically Centered</button>
	<button type="button" onclick="
		var mw = openModal('alert.html');
		mw.addEventListener('load', function() {
			var div = mw.contentWindow.document.body.firstElementChild;
			div.style.width = '800px';
			div.style.height = '500px';
		});
	">
		Initial Dimensions</button>

	<h2>TODO</h2>
	<h3>More design patterns</h3>
	<p>Draggable windows, edge snapping, etc.</p>
	
	<h3>Cross Origin Iframes</h3>
	<p>We plan to support cross origin iframes. The following limitations will apply:</p>
	<ul>
		<li>the iframe's document must also include openModal.js</li>
		<li>any inter-window communication you perform in <code>onload</code> must be limited to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage API</a></li>
		<li>any value passed to <code>closeModal()</code> must serializable by the postMessage API</li>
	</ul>

	<h3>Cross Browser Testing</h3>
	<p>'nough said.</p>

	<h3>Opera Mini Support</h3>
	<p>We rely on <code>position: fixed;</code>. Opera Mini appears to be the only current browser not supporting this (<a href="https://caniuse.com/#feat=css-fixed">https://caniuse.com/#feat=css-fixed</a>).</p>
	<p>We may be able to implement a fallback using <code>position: absolute;</code> and calculating the required top/left values using <code>iframe.getBoundingClientRect()</code> after initially placing it in the DOM.</p>

	<h3>Smarter Scroll Locking</h3>
	<p>We use a scoll event listener to lock the document scroll position, rather than setting <code>overflow: hidden;</code> while a modal is open.</p>
	<p>The latter technique is more efficient, and would prevent any "jitter" while the user scrolls. However, it should not be used if the browser renders scroll bars that take up space in the viewport (showing/hiding scrollbars when opening a modal can be distracting, or even break layouts entirely).</p>
	<p>We can probably detect, at the time <code>openModal()</code> is called, whether there are currently any "space taking" scrollbars, and use the most appropriate technique.</p>
</body>
</html>