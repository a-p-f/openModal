<!DOCTYPE html>
<html>
<head>
	<title>openModal Demo</title>
	<script defer src="openModal.js"></script>
	<link rel="stylesheet" href="./style.css">
</head>
<body>
	<h1>openModal - A New Concept For Modal Dialogs/Windows</h1>
	<h2>API</h2>
	<p><code>openModal(url)</code> creates a "ModalWindow" object, from the document at the specified url.</p>

	<p>The ModalWindow:</p>
	<ul>
		<li>blocks all user interaction in the parent window until closed</li>
		<li>covers the entire viewport</li>
		<li>has a transparent background, so need not <em>visually</em> block the entire parent window</li>
	</ul>

	<p>The ModalWindow implements:</p>
	<dl>
		<dt><code>contentWindow</code></dt>
		<dd>A Window object. This allows you to communicate with the modal.</dd>

		<dt><code>addEventListener/removeEventListener</code></dt>
		<dd>You can listen to "load" and "close" events. The load event is fired on every page load within the modal. The close event is fired when the ModalWindow is closed.</dd>

		<dt><code>close([value]) -> undefined</code></dt>
		<dd>Closes the ModalWindow. If given, <code>value</code> will be available on the close event as <code>event.detail</code></dd>
	</dl>

	<p>Inside the modal (inside it's <code>contentWindow</code>), the following will be available:</p>
	<dl>
		<dt><code>modalParent</code></dt>
		<dd>The opening/parent Window.</dd>
		<dt><code>modalClose([value]) -> undefined</code></dt>
		<dd>Allows the modal to close itself. If given, <code>value</code> will be available on the close event as <code>event.detail</code></dd>
	</dl>

	<p>The button below demonstrates all the features of the API. You can inspect it to see what the click handler does.</p>
	<button onclick="
		var mw = openModal('communication_demo.html');
		mw.addEventListener('load', function() {
			mw.contentWindow.initialize(5);
		})
		mw.addEventListener('close', function(e) {
			alert('the modal window closed with value '+e.detail);
		});

		// you can close the ModalWindow yourself
		setTimeout(function() {
			try {
				mw.close('baz');
			}
			catch(e) {
				// the ModalWindow closed itself
			} 
		}, 10000);
	">Demonstrate the API</button>

	<h2>Accessibility / Usability Features</h2>
	<button type="button" onclick="openModal('basic_features.html');">
		Show Me The Features</button>
	<button id="alert_something" onclick="alert('You clicked the test button');">
		(Test Button)</button>

	<h2>Nesting</h2>
	<p>Nesting is straightforward, with one caveat. To prevent infinite recursion, browsers block iframes from loading if their src matches the src of any parent iframe. See the "Infinite Recursion" section of the <a href="https://www.w3.org/TR/WD-frames-970331">relevant W3C document</a>.</p>
	<p>Generally, you won't have a need to open iframes in a cycle like this. If you do, just append a unique querystring to each src, like we do in this demo.</p>
	<button type="button" onclick="openModal('nestable_alert.html');">Show Me The Nesting</button>

	<h2>Going Native</h2>
	- no recursive url prevention
	- no z-index issues
	- standardize the design pattern
	- target=_modal
	- user reload reloads top-most
	- user back/forward navigate top-most, if possible
	- independent layers (if A opens B and does not add any event listeners):
		A opens B -> back will pop B, forward will push it again
		A can location.reload() UNDERNEATH B

	<h2>Tips/Patterns &amp; modalUtils</h2>
	<p>You already know everything there is to know about <code>openModal()</code>. Along with openModal.js, we also distribute modalUtils.js and modalUtils.css. These helper utilities help you implement common modal features/layouts. Note that your base page doesn't need to include modalUtils (css or js) - only your modal pages. You may find modalUtils useful even without openModal. Finally, you can use modalUtils.css directly, but you might also want to copy/paste the styles into your own stylesheet and modify as needed. We include an un-minified version in our distribution code, with lots of comments about the styles you may want to override/change.</p>

	<h3>Easy Exit</h3>
	<p>Close the modal when clicking outside the main "visible element" or by hitting the escape key:<br>
	<button onclick="openModal('easy_exit.html');">Easy Exit Demo</button>

	<h3>Full-page Layers</h3>
	<p>If your iframe performs navigation within itself, put a background color on iframe (rather than the html/body element). Otherwise, the parent window will show through during navigations. <br>
	<button type="button" onclick="openModal('full_page.html');">Without iframe background</button>
	<button type="button" onclick="
		openModal('full_page.html').style.backgroundColor = 'white';
	">With iframe background</button>

	<h3>Alert Modal</h3>
	<p>The alert modal we've been using thus far is very flexible. It requires two wrapper elements inside. You could get away with just one wrapper element if you didn't need horizontal scrolling, but we recommend using the full "AlertModal" markup as the base for all of your alert/window style modals.</p>
	
	<!-- TODO - fix/change/remove this suggestion -->
	<p>We recommend copying the <code>.AlertModal*</code> styles from <a href="./style.css">style.css</a>, and pasting into your own stylesheet. There are comments in the styles indicating the properties you may want to change/override.</p>
	<button type="button" onclick="openModal('alert.html');">
		Open Alert Modal</button>
	<button type="button" onclick="openModal('alert.html', function(iframe) {
		iframe.contentDocument.documentElement.classList.add('AlertModalTopBiased');
	});">
		"Top Biased" variant</button>
	<button type="button" onclick="openModal('alert.html', function(iframe) {
		iframe.contentDocument.documentElement.style.alignItems = 'center';
	});">
		Vertically Centered</button>
	<button type="button" onclick="openModal('alert.html', function(iframe) {
		var div = iframe.contentDocument.querySelector('.AlertModalScroller');
		div.style.width = '800px';
		div.style.height = '500px';
	});">
		Initial Dimensions</button>

	<h2>TODO</h2>
	<p>Max possible z-index? no reason for ayone, ever to appear above <br>
	2147483647 https://stackoverflow.com/questions/491052/minimum-and-maximum-value-of-z-index</p>
	<h3>Modal Utils</h3>
	<p>Create modal_utils.js and modal_utils.css. Move .AlertModal there. Create js helpers for draggable windows, edge snapping, etc. Move "easy exit" feature there, too.</p>

	<h3>Cross Origin Iframes</h3>
	<p>We plan to support cross origin iframes. The following limitations will apply:</p>
	<ul>
		<li>the iframe's document must also include openModal.js</li>
		<li>any inter-window communication you perform in <code>onload</code> must be limited to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage API</a></li>
		<li>any value passed to <code>modalClose()</code> must serializable by the postMessage API</li>
	</ul>

	<h3>Cross Browser Testing</h3>
	<p>'nough said.</p>

	<h3>Opera Mini Support</h3>
	<p>We rely on <code>position: fixed;</code>. Opera Mini appears to be the only current browser not supporting this (<a href="https://caniuse.com/#feat=css-fixed">https://caniuse.com/#feat=css-fixed</a>).</p>
	<p>We may be able to implement a fallback using <code>position: absolute;</code> and calculating the required top/left values using <code>iframe.getBoundingClientRect()</code> after initially placing it in the DOM.</p>

	<h3>Smarter Scroll Locking</h3>
	<p>We use a scoll event listener to lock the document scroll position, rather than setting <code>overflow: hidden;</code> while a modal is open.</p>
	<p>The latter technique is more efficient, and would prevent any "jitter" while the user scrolls. However, it should not be used if the browser renders scroll bars that take up space in the viewport (showing/hiding scrollbars when opening a modal can be distracting, or even break layouts entirely).</p>
	<p>We can probably detect, at the time <code>openModal()</code> is called, whether there are currently any "space taking" scrollbars, and use the most appropriate technique.</p>
</body>
</html>