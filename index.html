<!DOCTYPE html>
<html>
<head>
	<title>openModal Demo</title>
	<script defer src="openModal.js"></script>
	<link rel="stylesheet" href="./style.css">
</head>
<body>
	<strong>UNDER CONSTRUCTION</strong>
	<h1>openModal - A New Concept For Modal Dialogs/Windows</h1>
	<p><a href="openModal.js">openModal.js</a> allows you to easily create accessible, nestable, modal dialogs/windows.</p>
	<p>Think of <code>openModal(url)</code> as an alternative to <code>window.open(url)</code>. Instead of opening a new tab or pop-up window, it opens a "ModalWindow" over top of your existing page.</p>
	<p>Our implementation loads the the document in an iframe, but this detail is not exposed in the API. We've designed the API to be as simple as possible, and to mimic existing browser APIs, in the hopes that this function might one day be considered for native browser implementation.</p>

	<h2>API</h2>
	<p><code>openModal(url)</code> creates a "ModalWindow" object, from the document at the specified url.</p>

	<p>The ModalWindow:</p>
	<ul>
		<li>blocks all user interaction in the parent window until closed</li>
		<li>covers the entire viewport</li>
		<li>has a transparent background, so need not <em>visually</em> block the entire parent window</li>
	</ul>

	<p>The ModalWindow implements:</p>
	<dl>
		<dt><code>contentWindow</code></dt>
		<dd>A Window object. This allows you to communicate with the modal.</dd>

		<dt><code>addEventListener/removeEventListener</code></dt>
		<dd>You can listen to "load" and "close" events. The load event is fired on every page load within the modal. The close event is fired when the ModalWindow is closed.</dd>

		<dt><code>close([value]) -> undefined</code></dt>
		<dd>Closes the ModalWindow. If given, <code>value</code> will be available on the close event as <code>event.detail</code></dd>
	</dl>

	<p>Inside the modal (inside it's <code>contentWindow</code>), the following will be available:</p>
	<dl>
		<dt><code>modalParent</code></dt>
		<dd>The opening/parent Window.</dd>
		<dt><code>modalClose([value]) -> undefined</code></dt>
		<dd>Allows the modal to close itself. If given, <code>value</code> will be available on the close event as <code>event.detail</code></dd>
	</dl>

	<h2 id="demos">Demos</h2>
	<p>
		<button type="button" onclick="openModal('basic_features.html');">
			Accessibility / Usability Features</button>
		<button onclick="
			var mw = openModal('communication_demo.html');
			mw.addEventListener('load', function() {
				mw.contentWindow.initialize({
					value: 5,
					oncancel: function() {
						mw.close('NO VALUE');
					},
				});
			})
			mw.addEventListener('close', function(e) {
				alert('the modal window closed with value '+e.detail);
			});
		">Inter-window Communication</button>

		<button type="button" onclick="openModal('nestable_alert.html');">Nesting</button>

		<!-- 
			This button is here so that so that the 'basic_features.html' demo
			has something to try and click (programmatically)
		-->
		<br>

	</p>
	<p>
		Test button for the accessibility demo (it tries to click this): <br>
		<button id="alert_something" onclick="alert('You clicked the test button');">
			Test Button</button>
	</p>

	<h2>Going Native</h2>
	- no recursive url prevention
	- no z-index issues
	- standardize the design pattern
	- target=_modal
	- user reload reloads top-most
	- user back/forward navigate top-most, if possible
	- independent layers (if A opens B and does not add any event listeners):
		A opens B -> back will pop B, forward will push it again
		A can location.reload() UNDERNEATH B

	<h2>Tips &amp; Design Patterns</h2>

	<p>You already know everything there is to know about <code>openModal()</code>. What follows is a set of tips/techniques for implementing common design patterns.</p>

	<h3>Nesting</h3>
	<p>Nesting is straightforward, with one caveat. To prevent infinite recursion, browsers block iframes from loading if their src matches the src of any parent iframe. See the "Infinite Recursion" section of the <a href="https://www.w3.org/TR/WD-frames-970331">relevant W3C document</a>.</p>
	<p>Generally, you won't have a need to open iframes in a cycle like this. If you do, just append a unique querystring to each src, like we do in this demo:<br>
	<button type="button" onclick="openModal('nestable_alert.html');">Nesting Demo</button>
	</p>

	<h3>Easy Exit</h3>
	<p>Close the modal when clicking outside the main "visible element" or by hitting the escape key:<br>
	<button onclick="openModal('easy_exit.html');">Easy Exit Demo</button>

	<h3>Full-page Layers</h3>
	<p>If your modal window performs navigation within itself, put a background color on iframe (rather than the html/body element). Otherwise, the parent window will show through during navigations. <br>
	<button type="button" onclick="openModal('full_page.html');">Without iframe background</button>
	<button type="button" onclick="
		openModal('full_page.html').style.backgroundColor = 'white';
	">With iframe background</button>

	<h3>Alert Modal</h3>
	<p>The alert modal we've been using thus far is very flexible. It requires two wrapper elements inside. You could get away with just one wrapper element if you didn't need horizontal scrolling, but we recommend using the full "AlertModal" markup as the base for all of your alert/window style modals.</p>
	
	<!-- TODO - fix/change/remove this suggestion -->
	<p>We recommend copying the <code>.AlertModal*</code> styles from <a href="./style.css">style.css</a>, and pasting into your own stylesheet. There are comments in the styles indicating the properties you may want to change/override.</p>
	<button type="button" onclick="openModal('alert.html');">
		Open Alert Modal</button>
	<button type="button" onclick="openModal('alert.html', function(iframe) {
		iframe.contentDocument.documentElement.classList.add('AlertModalTopBiased');
	});">
		"Top Biased" variant</button>
	<button type="button" onclick="openModal('alert.html', function(iframe) {
		iframe.contentDocument.documentElement.style.alignItems = 'center';
	});">
		Vertically Centered</button>
	<button type="button" onclick="openModal('alert.html', function(iframe) {
		var div = iframe.contentDocument.querySelector('.AlertModalScroller');
		div.style.width = '800px';
		div.style.height = '500px';
	});">
		Initial Dimensions</button>

	<h2>TODO</h2>
	<p>Max possible z-index? no reason for ayone, ever to appear above <br>
	2147483647 https://stackoverflow.com/questions/491052/minimum-and-maximum-value-of-z-index</p>
	<h3>Modal Utils</h3>
	<p>Create modal_utils.js and modal_utils.css. Move .AlertModal there. Create js helpers for draggable windows, edge snapping, etc. Move "easy exit" feature there, too.</p>

	<h3>Cross Origin Iframes</h3>
	<p>We plan to support cross origin iframes. The following limitations will apply:</p>
	<ul>
		<li>the iframe's document must also include openModal.js</li>
		<li>any inter-window communication you perform in <code>onload</code> must be limited to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage API</a></li>
		<li>any value passed to <code>modalClose()</code> must serializable by the postMessage API</li>
	</ul>

	<h3>Cross Browser Testing</h3>
	<p>'nough said.</p>

	<h3>Opera Mini Support</h3>
	<p>We rely on <code>position: fixed;</code>. Opera Mini appears to be the only current browser not supporting this (<a href="https://caniuse.com/#feat=css-fixed">https://caniuse.com/#feat=css-fixed</a>).</p>
	<p>We may be able to implement a fallback using <code>position: absolute;</code> and calculating the required top/left values using <code>iframe.getBoundingClientRect()</code> after initially placing it in the DOM.</p>

	<h3>Smarter Scroll Locking</h3>
	<p>We use a scoll event listener to lock the document scroll position, rather than setting <code>overflow: hidden;</code> while a modal is open.</p>
	<p>The latter technique is more efficient, and would prevent any "jitter" while the user scrolls. However, it should not be used if the browser renders scroll bars that take up space in the viewport (showing/hiding scrollbars when opening a modal can be distracting, or even break layouts entirely).</p>
	<p>We can probably detect, at the time <code>openModal()</code> is called, whether there are currently any "space taking" scrollbars, and use the most appropriate technique.</p>
</body>
</html>