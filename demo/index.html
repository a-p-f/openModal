<!DOCTYPE html>
<html>
<head>
	<title>openModal Demo</title>
	<script defer src="/openModal/openModal.js"></script>
	<link rel="stylesheet" href="./style.css">
</head>
<body>
	<h1>openModal - Dead Simple Iframe Based Modal Dialogs</h1>
	<h2>Concept</h2>
	<p><code>openModal()</code> works much like <code>window.open()</code>. Instead of a native OS level window, however, it creates a full-page, modal iframe.</p>
	<p><code>openModal()</code> is infinitely nestable - any iframe can open another.</p>
	<p>Even though each iframe covers the entire viewport, it need not be fully opaque. Each iframe's document can decide:
	</p>
	<ul>
		<li>whether to cover the entire viewport with visible content</li>
		<li>whether to render a backdrop</li>
	</ul>
	<p>Each iframe can implement it's own:</p>
	<ul>
		<li>entrance/exit animations</li>
		<li>user interactions like drag/resize/snap to edges</li>
	</ul>
	<p>With this approach, you can easily create <strong>resuable, self-contained, cooperative, lazy loading</strong> widgets/user interfaces.</p>

	<h2>Installation</h2>
	TODO

	<h2>API</h2>

	<h3><code>openModal(url [, onload] [, onclose]) -> iframe</code></h3>
	<p>Create an iframe with <code>src</code> set to <code>url</code>, and position it such that it covers the entire viewport. Return the iframe.</p>
	<p><code>onload</code> will be called every time the iframe loads a new page, with the iframe as the sole argument. Use this callback to setup or initialize the child window.</p>
	<p><code>onclose</code> will be called when the iframe is removed via <code>closeModal([value])</code>. Any value passed to <code>closeModal</code> will be passed on to <code>onclose</code>. This callback isn't strictly necessary (you can setup two way communication using <code>onload</code>), but is a convenient way to pass information back from the child window to the parent.</p>

	<h3><code>closeModal([value])</code></h3>
	<p>Remove the iframe modal from the DOM, and invoke any <code>onclose</code> callback that was passed to <code>openModal</code>.</p>
	<p>This function is made available globally as a property of the iframe's <code>contentWindow</code>, and as a property on the iframe element (so either the parent window or the child window can dismiss the child).</p>

	<h3>Demo</h3>
	<p>The button below demonstrates all the features of the API. You can inspect it to see what the click handler does.</p>
	<button onclick="
		var iframe = openModal('communication_demo.html', function(iframe) {
			iframe.contentWindow.initialize(5);
		}, function(value) {
			alert('the child window closed with value '+value);
		});

		// you shouldn't often need to do much with the iframe,
		// but you might want to set a backgroundColor
		iframe.style.backgroundColor = '#DFD';

		// you can close the iframe yourself
		setTimeout(function() {
			if (!iframe.parentElement) {
				// The iframe already closed itself
				return
			}
			iframe.closeModal('baz');
		}, 10000);
	">Demonstrate the API</button>


	<h2>Accessibility / Usability Features</h2>
	<button type="button" onclick="openModal('basic_features.html');">
		Show Me The Features</button>
	<button id="alert_something" onclick="alert('You clicked the test button');">
		(Test Button)</button>

	<h2>Nesting</h2>
	<p>Nesting is straightforward, with one caveat. To prevent infinite recursion, browsers block iframes from loading if their src matches the src of any parent iframe. See the "Infinite Recursion" section of the <a href="https://www.w3.org/TR/WD-frames-970331">relevant W3C document</a>.</p>
	<p>Generally, you won't have a need to open iframes in a cycle like this. If you do, just append a unique querystring to each src, like we do in this demo.</p>
	<button type="button" onclick="openModal('nestable_alert.html');">Show Me The Nesting</button>

	<h2>Tips/Patterns</h2>
	<p>You already know everything there is to know about <code>openModal()</code>. What follows is a collection of tips/design patterns for implementing different types of modals.

	<h3>Easy Exit</h3>
	<p>Want to close the modal on backdrop click or escape key? See the event handlers on the html element in this modal. <br>
	<button onclick="openModal('easy_exit.html');">Easy Exit Demo</button>

	<h3>Full-page Layers</h3>
	<p>If your iframe performs navigation within itself, put a background color on iframe (rather than the html/body element). Otherwise, the parent window will show through during navigations. <br>
	<button type="button" onclick="openModal('full_page.html');">Without iframe background</button>
	<button type="button" onclick="
		openModal('full_page.html').style.backgroundColor = 'white';
	">With iframe background</button>

	<h3>Alert Modal</h3>
	<p>The alert modal we've been using thus far is very flexible. It requires two wrapper elements around all of the body contents. You could get away with just one wrapper element if you didn't need horizontal scrolling, but we recommend using the full "AlertModal" markup as a default.</p>
	<p>We recommend copying the <code>.AlertModal*</code> styles from <a href="./style.css">style.css</a>, and pasting into your own stylesheet. There are comments in the styles indicating the properties you may want to change/override.</p>
	<button type="button" onclick="openModal('alert.html');">
		Open Alert Modal</button>
	<button type="button" onclick="openModal('alert.html', function(iframe) {
		iframe.contentDocument.documentElement.classList.add('AlertModalTopBiased');
	});">
		"Top Biased" variant</button>
	<button type="button" onclick="openModal('alert.html', function(iframe) {
		iframe.contentDocument.documentElement.style.alignItems = 'center';
	});">
		Vertically Centered</button>
	<button type="button" onclick="openModal('alert.html', function(iframe) {
		var div = iframe.contentDocument.querySelector('.AlertModalScroller');
		div.style.width = '800px';
		div.style.height = '500px';
	});">
		Initial Dimensions</button>

	<h2>TODO</h2>
	<h3>Modal Utils</h3>
	<p>Create modal_utils.js and modal_utils.css. Move .AlertModal there. Create js helpers for draggable windows, edge snapping, etc. Move "easy exit" feature there, too.</p>

	<h3>Cross Origin Iframes</h3>
	<p>We plan to support cross origin iframes. The following limitations will apply:</p>
	<ul>
		<li>the iframe's document must also include openModal.js</li>
		<li>any inter-window communication you perform in <code>onload</code> must be limited to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage API</a></li>
		<li>any value passed to <code>closeModal()</code> must serializable by the postMessage API</li>
	</ul>

	<h3>Cross Browser Testing</h3>
	<p>'nough said.</p>

	<h3>Opera Mini Support</h3>
	<p>We rely on <code>position: fixed;</code>. Opera Mini appears to be the only current browser not supporting this (<a href="https://caniuse.com/#feat=css-fixed">https://caniuse.com/#feat=css-fixed</a>).</p>
	<p>We may be able to implement a fallback using <code>position: absolute;</code> and calculating the required top/left values using <code>iframe.getBoundingClientRect()</code> after initially placing it in the DOM.</p>

	<h3>Smarter Scroll Locking</h3>
	<p>We use a scoll event listener to lock the document scroll position, rather than setting <code>overflow: hidden;</code> while a modal is open.</p>
	<p>The latter technique is more efficient, and would prevent any "jitter" while the user scrolls. However, it should not be used if the browser renders scroll bars that take up space in the viewport (showing/hiding scrollbars when opening a modal can be distracting, or even break layouts entirely).</p>
	<p>We can probably detect, at the time <code>openModal()</code> is called, whether there are currently any "space taking" scrollbars, and use the most appropriate technique.</p>
</body>
</html>